#' Match Pangolin prediction of splice sites gain or loss with observed junctions
#'
#' @param gdb_path string The path to GDB database that store the genotype data from whole genome sequencing. The GDB database should contain Pangolin prediction table.
#' @param cohort_name string The table name in GDB database that contain sample metadata
#' @param var2junc string or data.frame One row in the the dataframe is an annotated DNA variant that mapped to a novel junction in a subject's tissues. 
#' @param pangolin_table_name string The table of Pangolin predictions in the GDB database
#' @param min_pangolin_score float Minimum Pangolin score. The predictions of splice sites that score higher than the minimum score will be matched with observed junctions.
#' @param max_skip_exon integer If a novel junction skips more exons than the provided number, it will be considered as "not match" to prediction. Default to 2.  
#' @param reference string The directory to genomic annotation files, which can be generated by prepareGenoRef function. Default to pre-made ensembl annotation version GRCh38.98.
#' 
#' @return data.frame Column "match_by_threshold" shows whether the prediction of variants matched the corresponding novel junction. "NA" in the column means either the prediction score is under given threshold, or the prediction is a gain of annotated site or a loss of novel site which is out the scope of this function. 
#' @import RSQLite
#' @import SummarizedExperiment
#' @import rvat
#' @import dplyr
#' @export
#'
matchPredNObs_pangolin <-
  function(gdb_path, cohort_name, var2junc, pangolin_table_name, min_pangolin_score, max_skip_exon = 2, reference = "Default"){
    
    if (reference == "Default"){
      ref_intron = system.file(paste("extdata", "Reference", "Intron_GRCh38.98.proteincoding.bed", sep=.Platform$file.sep), package = "SpliPath")
      ref_exon = system.file(paste("extdata", "Reference", "Exon_GRCh38.98.proteincoding.bed", sep=.Platform$file.sep), package = "SpliPath")
    }else{
      ref_intron = paste(reference, "Intron.proteincoding.bed", sep=.Platform$file.sep)
      ref_exon = paste(reference, "Exon.proteincoding.bed", sep=.Platform$file.sep)
    }
    intron_ref = read.table(ref_intron, sep='\t', header=F, stringsAsFactors = F) 
    colnames(intron_ref) = c('chr',  'start', 'end', 'transcript.id',  'gene.id', 'strand')
    intron_ref$end = as.integer(intron_ref$end) + 1 ### Specific to Pangolin
    
    intron_ref$intron = paste(intron_ref$chr, intron_ref$start,  intron_ref$end,  intron_ref$strand,  intron_ref$gene.id, sep = ":")
    intron_ref = intron_ref[!duplicated(intron_ref$intron), ]
    intron_ref = subset(intron_ref, select = -c(intron, transcript.id))
    intron_ref$anno_start = paste(intron_ref$chr, intron_ref$start, intron_ref$strand, intron_ref$gene.id, sep = ":")
    intron_ref$anno_end = paste(intron_ref$chr, intron_ref$end, intron_ref$strand, intron_ref$gene.id, sep = ":")
    
    if (!is.data.frame(var2junc)){
      var2junc = read.table(var2junc, header=T, sep="\t", stringsAsFactors = F)
    }
    var2junc = tidyr::separate(var2junc, col="Coordinates_of_unannotated_junc", into=c("chr", "start", "end", "strand"), sep=":", remove = F)
    var2junc = var2junc[, c("VAR_id", "DNA_variant", "Coordinates_of_unannotated_junc", "Event", "Gene_id", "Gene", "Var_region", "chr", "start", "end", "strand")]
    var2junc = unique(var2junc)
    var2junc = subset(var2junc, Event %in% c("exon_skipping", "unannotated_donor", "unannotated_acceptor"))
    var2junc$start.pos = paste(var2junc$chr, var2junc$start, var2junc$strand, var2junc$Gene_id, sep = ":")
    var2junc$end.pos = paste(var2junc$chr, as.integer(var2junc$end) + 1, var2junc$strand, var2junc$Gene_id, sep = ":")
    
    mygdb = rvat::gdb(gdb_path)
    pangolin = rvat::getAnno(mygdb, table = pangolin_table_name)
    var2junc[, c("VAR_id")] = sapply(var2junc[, c("VAR_id")], FUN = as.integer)
    pangolin = pangolin[pangolin$VAR_id %in% var2junc$VAR_id, ]
    pangolin = tidyr::separate(pangolin, col="gene_id", into=c("pangolinGENE", NA), sep="[.]")
    
    pangolin_pred = c("pos_increase", "score_increase", "pos_decrease", "score_decrease")
    pangolin[, c("POS", pangolin_pred)] = sapply(pangolin[, c("POS", pangolin_pred)], FUN=as.numeric)
    pangolin$score_decrease = abs(pangolin$score_decrease)
    pangolin$MaxDS = apply(pangolin[, c("score_increase", "score_decrease")], 1, max)  
    pangolin = subset(pangolin,  MaxDS > 0)
    if (sum(pangolin$MaxDS >= min_pangolin_score) == 0){
      stop("No variants have a Pangolin score greater then the input 'min_pangolin_score'.")
    }
    
    ### Convert scores when REF is the minor allele
    GT = rvat::getGT(mygdb, VAR_id = pangolin$VAR_id, cohort=cohort_name)
    pangolin$AF = rowData(GT)[as.character(pangolin$VAR_id), "AF"]
    rm(GT)
    pangolin[pangolin$AF > 0.5, pangolin_pred ] = pangolin[pangolin$AF > 0.5, c("pos_decrease", "score_decrease", "pos_increase", "score_increase") ]
    
    matched = dplyr::inner_join(var2junc, pangolin, by = c("VAR_id"))
    matched = matched[matched$Gene_id == matched$pangolinGENE, ] ###
    matched$VAR_id = as.character(matched$VAR_id)
    matched$idx = paste(matched$VAR_id, matched$Coordinates_of_unannotated_junc, matched$Gene_id, sep=":")
    
    ### Redefine splice start site and end site at forward strand
    matched$pangolinPG = matched$POS + matched$pos_increase 
    matched$pangolinPL = matched$POS + matched$pos_decrease 
    matched[, c("pangolinDS_G", "pangolinDS_L")] = matched[, c("score_increase", "score_decrease")] >= min_pangolin_score
    
    matched$pangolinPG_idx = paste(matched$chr, matched$pangolinPG, matched$strand, matched$Gene_id, sep=":")
    matched$pangolinPL_idx = paste(matched$chr, matched$pangolinPL, matched$strand, matched$Gene_id, sep=":")
    
    match_sites = paste0("match_", c("PG", "PL"))
    score_sites = paste0("pangolin", c("DS_G", "DS_L"))
    
    matched[, match_sites] = FALSE
    
    ### Prediction on gain of annotated splice site & loss of novel splice site are out of scope
    matched[(matched$pangolinDS_G & (matched$pangolinPG_idx %in% c(intron_ref$anno_start, intron_ref$anno_end))), "pangolinDS_G"] = FALSE
    matched[(matched$pangolinDS_L & (!matched$pangolinPL_idx %in% c(intron_ref$anno_start, intron_ref$anno_end))), "pangolinDS_L"] = FALSE
    
    ### Match lost of annotated sites 
    matched_cryptic_loss_all = subset(matched, (pangolinDS_L & (pangolinPL_idx %in% c(intron_ref$anno_start, intron_ref$anno_end))) )
    for (var in unique(matched_cryptic_loss_all$VAR_id)){
      matched_cryptic_loss_var = subset(matched_cryptic_loss_all, VAR_id == var)
      
      annotated_end = unique(subset(intron_ref, anno_start %in% matched_cryptic_loss_var$pangolinPL_idx, select = anno_end, drop=T))
      annotated_start = unique(subset(intron_ref, anno_end %in% matched_cryptic_loss_var$pangolinPL_idx, select = anno_start, drop=T))
      matched_cryptic_loss_var_ = subset(matched_cryptic_loss_var, (end.pos %in% annotated_end) | (start.pos %in% annotated_start) )
      if (nrow(matched_cryptic_loss_var_) > 0){
        matched[matched$idx %in% matched_cryptic_loss_var_$idx, "match_PL"] = TRUE
      }
    }
    
    ### Match gained of novel site 
    matched_cryptic_gain = subset(matched, ((!pangolinPG_idx %in% intron_ref$anno_start) & pangolinDS_G & pangolinPG == start) | ((!pangolinPG_idx %in% intron_ref$anno_end) & pangolinDS_G & pangolinPG == end) )
    
    matched[matched$idx %in% matched_cryptic_gain[(matched_cryptic_gain$pangolinPG == matched_cryptic_gain$start) & (!matched_cryptic_gain$pangolinPG_idx %in% intron_ref$anno_start), "idx"], "match_PG"] = TRUE
    matched[matched$idx %in% matched_cryptic_gain[(matched_cryptic_gain$pangolinPG == matched_cryptic_gain$end) & (!matched_cryptic_gain$pangolinPG_idx %in% intron_ref$anno_end), "idx"], "match_PG"] = TRUE
    
    ### Use provided Pangolin score threshold
    matched[, c("pangolinDS_G", "pangolinDS_L")] = matched[, c("score_increase", "score_decrease")] >= min_pangolin_score
    
    ### Prediction on gain of annotated splice site & loss of novel splice site are out of scope
    matched[(matched$pangolinDS_G & (matched$pangolinPG_idx %in% c(intron_ref$anno_start, intron_ref$anno_end))), "pangolinDS_G"] = FALSE
    matched[(matched$pangolinDS_L & (!matched$pangolinPL_idx %in% c(intron_ref$anno_start, intron_ref$anno_end))), "pangolinDS_L"] = FALSE
    
    ### Judge match or not by number of matched and mis-matched sites
    matched[, score_sites][ which(matched[, score_sites] == FALSE, arr.ind = T) ] = NA
    matched$matched_site = rowSums(matched[, score_sites] * matched[, match_sites], na.rm = T)
    matched$miss_matched_site = rowSums((matched[, score_sites] * matched[, match_sites]) == 0, na.rm = T)
    matched$match_by_threshold[matched$matched_site > 0 & matched$miss_matched_site == 0 ] = "full_match"
    matched$match_by_threshold[matched$matched_site > 0 & matched$miss_matched_site > 0] = "partial_match"
    matched$match_by_threshold[matched$matched_site == 0 & matched$miss_matched_site > 0] = "not_match"
    matched$match_by_threshold[matched$matched_site == 0 & matched$miss_matched_site == 0] = "not_match"
    
    matched = matched[order(matched$VAR_id, -matched$matched_site), ]
    
    ### Count how many exons the cryptic introns skip
    matched_gr = GenomicRanges::makeGRangesFromDataFrame(matched, seqnames.field = "chr", start.field = "start", end.field = "end", strand.field = "strand", keep.extra.columns = TRUE)
    ref_exon = read.table(ref_exon, sep="\t", header = F, stringsAsFactors = F)
    colnames(ref_exon) = c("chr", "start", "end", "exon.id", "gene.id", "strand")
    ref_exon = ref_exon[!duplicated(ref_exon[, c("chr", "start", "end", "strand", "gene.id")]), ]
    ref_exon = ref_exon %>% dplyr::group_by(chr, gene.id, strand, start) %>% dplyr::summarise(across(end, max))
    ref_exon = data.frame(ref_exon %>% dplyr::group_by(chr, gene.id, strand, end) %>% dplyr::summarise(across(start, min)))
    ref_exon = GenomicRanges::makeGRangesFromDataFrame(ref_exon, seqnames.field = "chr", start.field = "start", end.field = "end", strand.field = "strand", keep.extra.columns = TRUE)
    overlap_exon = data.frame(GenomicRanges::findOverlaps(ref_exon, matched_gr, type = "within"))
    
    ref_exon = data.frame(ref_exon, stringsAsFactors=F)
    colnames(ref_exon) = paste0("exon_", colnames(ref_exon))
    idx = as.numeric(overlap_exon$subjectHits)
    overlap_exon = cbind(ref_exon[as.numeric(overlap_exon$queryHits), ], matched[as.numeric(overlap_exon$subjectHits), ])
    overlap_exon$idx = idx; rm(idx)
    overlap_exon = overlap_exon[overlap_exon$exon_gene.id == overlap_exon$gene.id, ]
    nr_exon_start = overlap_exon %>% dplyr::distinct(idx, exon_start) %>% dplyr::count(idx)
    nr_exon_end = overlap_exon %>% dplyr::distinct(idx, exon_end) %>% dplyr::count(idx)
    overlap_exon = dplyr::full_join(nr_exon_start, nr_exon_end, by="idx")
    overlap_exon$n = do.call(pmin, overlap_exon[, c("n.x", "n.y")])
    matched$junc_skip_nr_exon = 0
    matched[as.numeric(overlap_exon$idx), "junc_skip_nr_exon"] = overlap_exon$n
    
    matched[matched$junc_skip_nr_exon > max_skip_exon, "match_by_threshold"] = "not_match"
    matched
  }