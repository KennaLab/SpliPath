#' Nominate csQTLs by matching SpliceAI predictions of the genetic variants to the provided splicing junctions
#' 
#'
#' @param junc_anno_file string or data.frame The output file of annotateJunc function, which contain junction annotations.
#' @param paired_data logical Find collapsed sQTL in paired data mode "TRUE" or unpaired data mode "FALSE". If TRUE, arguments rna_meta and wgs_meta are required. The function matches the paired samples by 'SubjectID' in the metadata.   
#' @param gdb_path string The path to GDB database that store the genotype data from whole genome sequencing.
#' @param cohort_name string The table name in GDB database that contain sample metadata
#' @param rna_meta string RNAseq sample metadata file. The file should contain at least "SampleID", "SubjectID", "Group, "Tissue" columns.
#' @param wgs_meta string WGS sample metadata file. The file should contain at least "SampleID", "SubjectID", "Group columns.
#' @param reference string The directory to genomic annotation files, which can be generated by prepareGenoRef function. Default to pre-made ensembl annotation version GRCh38.98.
#' @param max_allele_freq numeric Maximum allele frequency to nominate csQTL candidate.
#' @param spliceai_prediction list The names of elements in the list is the prediction tool, it should be in GDB database tables. The items are the scoring fields in the GDB database prediction table. The maximum of the given scores will be used as the prediction of the corresponding tool for each variants. E.g. The SpliceAI score of a variant will be the maximum of spliceaiDS_AG, "pliceaiDS_AL, spliceaiDS_DG, and spliceaiDS_DL. Default: list(SpliceAI = c("spliceaiDS_AG", "spliceaiDS_AL", "spliceaiDS_DG", "spliceaiDS_DL")). 
#' @param min_splice_score list The min splice score of each prediction tools to nominate ultra rare sQTL candidate. A min score for SpliceAI must be in the list. Default: list(SpliceAI = 0.2, dbscSNV = 0.7).The predictions of splice sites that score higher than the minimum SpliceAI score will be matched with observed junctions.
#' @param max_skip_exon integer If a novel junction skips more exons than the provided number, it will be considered as "not match" to prediction. Default to 2.  
#' @param spliceai_default_reference logical Set to TRUE if the SpliceAI predictions are pre-computed or SpliceAI default annotation were used when running SpliceAI (-A GRCh38, or -A GRCh37). Default to FALSE, indicating the annotation GTF are the same for junction annotation and SpliceAI prediction. 
#' @param blacklist string or NULL Optional. A genomic region blacklist. If provided, the regions will be removed.  Default: system.file("extdata/Reference/blacklist/hg38-blacklist-nochr.v2.bed.gz", package="SpliPath").
#' @param output_prefix string The mapping results will be written in output_prefix_map.txt.gz
#'
#' @import rvat
#' @import RSQLite
#' @import GenomicRanges
#' @import dplyr
#' @import tidyr
#' @export 
collapsedsQTL <-
  function(junc_anno_file, 
           paired_data, 
           gdb_path, 
           cohort_name, 
           rna_meta = NULL, 
           wgs_meta = NULL,
           max_allele_freq = 0.05,
           reference = "Default",
           spliceai_prediction=list(SpliceAI = c("spliceaiDS_AG", "spliceaiDS_AL", "spliceaiDS_DG", "spliceaiDS_DL")),
           min_spliceai_score = 0.2,
           spliceai_default_reference = FALSE,
           max_skip_exon = 2,
           blacklist = system.file(paste("extdata", "Blacklist", "hg38-blacklist-nochr.v2.bed.gz", sep=.Platform$file.sep), package = "SpliPath"),
           output_prefix = ""){

    ### Read-in input files first

    # Get sQTL search space of the junctions
    junc_anno = read.table(junc_anno_file, header=T, sep="\t", stringsAsFactors = F, check.names = F)
    
    junc_var_region = juncVariantRegion(unique(junc_anno[, c('chr', 'start', 'end', 'strand', 'gene.id', 'gene.name', 'event')]), 
                                        output_prefix = output_prefix, reference = reference)
    junc_var_region$Coordinates_of_unannotated_junc = paste(junc_var_region$chr, junc_var_region$start, junc_var_region$end, junc_var_region$strand, sep=":")
    junc_var_region = junc_var_region[, c("chr", "region.start", "region.end", "strand", "junc", "Coordinates_of_unannotated_junc", "event", "gene.name", "gene.id")]
    junc_var_region[, c("chr", "region.start", "region.end", "strand", "junc", "Coordinates_of_unannotated_junc", "event", "gene.name", "gene.id")] = sapply(junc_var_region[, c("chr", "region.start", "region.end", "strand", "junc", "Coordinates_of_unannotated_junc", "event", "gene.name", "gene.id")] , FUN=as.vector)
    colnames(junc_var_region)[2:3] = c("start", "end")
    junc_var_region = junc_var_region[order(junc_var_region$chr, junc_var_region$start), ]
    
    # Get variants and annotation from GDB
    pred_field = paste(paste0(names(spliceai_prediction), ".*"), collapse = ", ")
    query = sprintf("select VAR_id, var.CHROM, var.POS, var.REF, var.ALT, %s from var ", pred_field)
    for (item in names(spliceai_prediction)){
      query = paste0(query, sprintf(" left join %s using ('VAR_id')", item))
    }
    query = paste0(query, sprintf(" where var.CHROM in ('%s') ", paste(c(paste0('chr', unique(junc_var_region$chr)), sub("^chr", "", unique(junc_var_region$chr))), collapse = "', '")))
    
    mygdb = rvat::gdb(gdb_path)
    vars = RSQLite::dbGetQuery(mygdb, query)
    vars[is.na(vars)] = 0
    for (item in names(spliceai_prediction)){
      vars[, spliceai_prediction[[item]]] = sapply(vars[, spliceai_prediction[[item]]], as.numeric)
      vars[[item]] = apply(vars[, spliceai_prediction[[item]]], 1, max)
      vars = vars[, !colnames(vars) %in% spliceai_prediction[[item]]]
    }
    vars = vars[apply(vars[, names(spliceai_prediction), drop = F], 1, max) > 0, ]
    
    if (!grepl(junc_var_region$chr[1], 'chr', fixed = T)){
      vars$CHROM = sub("^chr", "", vars$CHROM)
    }else{
      if (!grepl(vars$CHROM[1], 'chr', fixed = T)){
        vars$CHROM = paste0("chr", vars$CHROM)
      }
    }
    vars$DNA_variant = paste0(vars$CHROM, ":g.", vars$POS, vars$REF, ">", vars$ALT)
    vars = vars[, c("CHROM", "POS", names(spliceai_prediction), "VAR_id", "DNA_variant")]
    vars = vars[order(vars$CHROM, as.integer(vars$POS)), ]
    
    # Get variants AF
    geno = rvat::getGT(mygdb, VAR_id=unique(vars$VAR_id), cohort=cohort_name)
    AF = rvat::getAF(geno)
    vars$AF = AF[as.character(vars$VAR_id)]
    rm(geno, AF)
    
    ### Map variant to aberrant splicing region
    vars_gr = GenomicRanges::makeGRangesFromDataFrame(vars, start.field = "POS", end.field = "POS", keep.extra.columns = T )
    junc_var_region_gr = GenomicRanges::makeGRangesFromDataFrame(junc_var_region, starts.in.df.are.0based = T, keep.extra.columns = T )
    overlaps = GenomicRanges::findOverlaps(vars_gr, junc_var_region_gr)
    if (length(overlaps) == 0){stop("No variant was mapped to novel junctions")}
    
    vars_gr = as.data.frame(vars_gr[data.frame(overlaps)$queryHits], stringsAsFactors = F, row.names = NULL)
    vars_gr = vars_gr[, c("seqnames", "start", names(spliceai_prediction), "VAR_id", "DNA_variant", "AF")]
    colnames(vars_gr) = c("chr", "pos", names(spliceai_prediction), "VAR_id", "DNA_variant", "AF")
    
    junc_var_region_gr = as.data.frame(junc_var_region_gr[data.frame(overlaps)$subjectHits], stringsAsFactors = F, row.names = NULL)
    junc_var_region_gr = junc_var_region_gr[, c("seqnames", "start", "end", "strand", "junc", "Coordinates_of_unannotated_junc", "event", "gene.name", "gene.id")]
    colnames(junc_var_region_gr) = c("region.chr", "region.start", "region.end", "region.strand", "junc", "Coordinates_of_unannotated_junc", "Event", "Gene", "Gene_id")
    var2junc = cbind(vars_gr, junc_var_region_gr)
    var2junc$VAR_id = as.character(var2junc$VAR_id)
    var2junc$Var_region = paste(var2junc$region.chr, var2junc$region.start, var2junc$region.end, sep=":")

    rm(junc_var_region, vars)
    
    # Match observed junction with SpliceAI prediction
    print("Matching variants with junctions ...")
    spliceai_pred_match = matchPredNObs(gdb_path = gdb_path, 
                                        cohort_name = cohort_name,
                                        var2junc, #tissue_map, 
                                        min_spliceai_score = min_spliceai_score, 
                                        max_skip_exon = max_skip_exon,
                                        reference = reference,
                                        spliceai_default_reference = spliceai_default_reference)

    var2junc = dplyr::left_join(var2junc, 
                                spliceai_pred_match[, !colnames(spliceai_pred_match) %in% 
                                                                c("chr", "start", "end", "strand", "start.pos", "end.pos", "MaxDS", "AF", "spliceaiSG_idx", "spliceaiEG_idx", "spliceaiSL_idx", "spliceaiEL_idx")],
                                by = c("VAR_id", "DNA_variant", "Coordinates_of_unannotated_junc", "Event", "Gene", "Gene_id", "Var_region"),
                                multiple = "all")
    
    reads_colnames = colnames(junc_anno)[grepl("Reads_", colnames(junc_anno))]
    pval_colnames = colnames(junc_anno)[grepl("Outlier_P_", colnames(junc_anno))]
    
    ### Get variant carriers and their genotype for the paired data analysis
    if (paired_data){
      var_carrier = getVarCarrier(rna_meta, wgs_meta, unique(var2junc$VAR_id), mygdb, cohort_name)
      var2junc = dplyr::inner_join(var2junc, var_carrier, by = c("VAR_id"), multiple = "all")
      var2junc = dplyr::inner_join(var2junc, junc_anno[, c("SubjectID", "Junc", "gene.id", "gene.name", reads_colnames, pval_colnames)], by = c("SubjectID", "Coordinates_of_unannotated_junc" = "Junc", "Gene" = "gene.name", "Gene_id" = "gene.id"), multiple = "all")
    }


    ### Use thresholds to determine csQTL candidates
    var2junc$csQTL_candidate = F
    var2junc[var2junc$match_by_threshold %in% c("full_match", "partial_match"), "csQTL_candidate"] = T
    var2junc[var2junc$AF > max_allele_freq & (1 - var2junc$AF) > max_allele_freq, "csQTL_candidate"] = F
    
    if (paired_data){
      output_prefix = paste0(output_prefix, "_paired")
    }else{
      output_prefix = paste0(output_prefix, "_unpaired")
    }
    output_file = gzfile(sprintf("%s_csQTL.txt.gz", output_prefix), "w")
    write.table(var2junc, output_file, sep="\t", quote=F, row.names = F)
    close(output_file)
    
  }

