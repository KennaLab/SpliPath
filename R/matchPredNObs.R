#' Match SpliceAI prediction of splice sites gain or loss with observed junctions
#'
#' @param gdb_path string The path to GDB database that store the genotype data from whole genome sequencing. The GDB database should contain SpliceAI prediction table.
#' @param cohort_name string The table name in GDB database that contain sample metadata
#' @param var2junc string or data.frame One row in the the dataframe is an annotated DNA variant that mapped to a novel junction in a subject's tissues. 
#' @param min_SpliceAI_score float Minimum SpliceAI delta score. The predictions of splice sites that score higher than the minimum SpliceAI delta score will be matched with observed junctions.
#' @param max_skip_exon integer If a novel junction skips more exons than the provided number, it will be considered as "not match" to prediction. Default to 2.  
#' @param reference string The directory to genomic annotation files, which can be generated by prepareGenoRef function. Default to pre-made ensembl annotation version GRCh38.98.
#' @param spliceai_default_reference logical Set to TRUE if the SpliceAI predictions are pre-computed or SpliceAI default annotation were used when running SpliceAI (-A GRCh38, or -A GRCh37). Default to FALSE, indicating the annotation GTF are the same for junction annotation and SpliceAI prediction. 
#' 
#' @return data.frame Column "match_by_threshold" shows whether the prediction of variants matched the corresponding novel junction. "NA" in the column means either the prediction score is under given threshold, or the prediction is a gain of annotated site or a loss of novel site which is out the scope of this function. 
#' The "SG", "SL", "EG", and "EL" in the column names means "start gain", "start loss", "end gain", and "end loss".
#' @import RSQLite
#' @import SummarizedExperiment
#' @import rvat
#' @import dplyr
#' @export
#'
matchPredNObs <-
function(gdb_path, cohort_name, var2junc, min_SpliceAI_score, max_skip_exon = 2, reference = "Default", spliceai_default_reference = FALSE){
  
  if (reference == "Default"){
    ref_intron = system.file(paste("extdata", "Reference", "Intron_GRCh38.98.proteincoding.bed", sep=.Platform$file.sep), package = "SpliPath")
    ref_exon = system.file(paste("extdata", "Reference", "Exon_GRCh38.98.proteincoding.bed", sep=.Platform$file.sep), package = "SpliPath")
  }else{
    ref_intron = paste(reference, "Intron.proteincoding.bed", sep=.Platform$file.sep)
    ref_exon = paste(reference, "Exon.proteincoding.bed", sep=.Platform$file.sep)
  }
  intron_ref = read.csv(ref_intron, sep='\t', header=F, stringsAsFactors = F) 
  colnames(intron_ref) = c('chr',  'start', 'end', 'transcript.id',  'gene.id', 'strand')
  
  intron_ref$intron = paste(intron_ref$chr, intron_ref$start,  intron_ref$end,  intron_ref$strand,  intron_ref$gene.id, sep = ":")
  intron_ref = intron_ref[!duplicated(intron_ref$intron), ]
  intron_ref = subset(intron_ref, select = -c(intron, transcript.id))
  intron_ref$anno_start = paste(intron_ref$chr, intron_ref$start, intron_ref$strand, intron_ref$gene.id, sep = ":")
  intron_ref$anno_end = paste(intron_ref$chr, intron_ref$end, intron_ref$strand, intron_ref$gene.id, sep = ":")
  
  if (!is.data.frame(var2junc)){
    var2junc = read.table(var2junc, header=T, sep="\t", stringsAsFactors = F)
  }
  var2junc = tidyr::separate(var2junc, col="Coordinates_of_novel_junc", into=c("chr", "start", "end", "strand"), sep=":", remove = F)
  var2junc = var2junc[, c("VAR_id", "DNA_variant", "Coordinates_of_novel_junc", "Event", "Gene_id", "Gene", "Var_region", "chr", "start", "end", "strand")]
  var2junc$VAR_id = as.character(var2junc$VAR_id)
  var2junc = unique(var2junc)
  var2junc = subset(var2junc, Event %in% c("exon_skipping", "novel_donor", "novel_acceptor"))  
  var2junc$start.pos = paste(var2junc$chr, var2junc$start, var2junc$strand, var2junc$Gene_id, sep = ":")
  var2junc$end.pos = paste(var2junc$chr, var2junc$end, var2junc$strand, var2junc$Gene_id, sep = ":")
  
  mygdb = rvat::gdb(gdb_path)
  spliceai = rvat::getAnno(mygdb, VAR_id=var2junc$VAR_id, table="SpliceAI")
  spliceai = subset(spliceai, !is.na(spliceaiSYMBOL))
  if ( grepl("---", spliceai$spliceaiSYMBOL[1]) ){
    spliceai = tidyr::separate(spliceai, col="spliceaiSYMBOL", into=c("spliceaiSYMBOL", "spliceaiGENE", "transcript", "biotype"), sep="---")
  }
  spliceai_pred = c("spliceaiDS_AG", "spliceaiDS_AL", "spliceaiDS_DG", "spliceaiDS_DL","spliceaiDP_AG", "spliceaiDP_AL", "spliceaiDP_DG", "spliceaiDP_DL")
  spliceai[, c("POS", spliceai_pred)] = sapply(spliceai[, c("POS", spliceai_pred)], FUN=as.numeric)
  spliceai$MaxDS = apply(spliceai[, spliceai_pred[1:4]], 1, max)  
  spliceai$VAR_id = as.character(spliceai$VAR_id)
  spliceai = subset(spliceai,  MaxDS > 0)
  if (sum(spliceai$MaxDS >= min_SpliceAI_score) == 0){
    stop("No variants have a SpliceAI score greater then the input 'min_SpliceAI_score'.")
  }
  
  ### If users used SpliceAI default annotation for predicting splicing change, convert gene name to gene id 
  if (spliceai_default_reference == TRUE){
    spliceai_name2id = system.file(paste("extdata", "Reference", "spliceai_gene_name2id_gencode.v24.bed", sep=.Platform$file.sep), package = "SpliPath")
    spliceai_name2id = read.table(spliceai_name2id, sep="\t", header=F, stringsAsFactors = F) 
    colnames(spliceai_name2id) = c("name", "id")
    spliceai$spliceaiGENE = spliceai_name2id[match(toupper(spliceai$spliceaiSYMBOL), toupper(spliceai_name2id$name)), "id"] ###
    
    if (sum(is.na(spliceai$spliceaiGENE)) > 0){
      warning(sprintf("Did not find gene ID for %s", paste(spliceai[!is.na(spliceai$spliceaiGENE), "spliceaiSYMBOL"], sep=",")))
    }
    spliceai = spliceai[!is.na(spliceai$spliceaiGENE), ]
  }
  
  
  ### Convert scores when REF is the minor allele
  GT = rvat::getGT(mygdb, VAR_id = spliceai$VAR_id, cohort=cohort_name)
  spliceai$AF = rowData(GT)[as.character(spliceai$VAR_id), "AF"]
  rm(GT)
  spliceai[spliceai$AF > 0.5, spliceai_pred ] = spliceai[spliceai$AF > 0.5, c("spliceaiDS_AL", "spliceaiDS_AG", "spliceaiDS_DL", "spliceaiDS_DG", "spliceaiDP_AL", "spliceaiDP_AG", "spliceaiDP_DL", "spliceaiDP_DG") ]
  
  matched = dplyr::inner_join(var2junc, spliceai, by = c("VAR_id"))
  if (sum(matched$Gene_id == matched$spliceaiGENE) == 0){
    # If all the gene ids are not the same, try to match with gene names
    matched = matched[matched$Gene == matched$spliceaiSYMBOL, ]
  }else{
    matched = matched[matched$Gene_id == matched$spliceaiGENE, ]
  }###
  matched$VAR_id = as.character(matched$VAR_id)
  matched$idx = paste(matched$VAR_id, matched$Coordinates_of_novel_junc, matched$Gene_id, sep=":")

  ### Redefine splice start site and end site at forward strand
  forward_strand = matched$strand == "+"
  if (sum(forward_strand) > 0){
    matched[forward_strand, "spliceaiEG"] = matched[forward_strand, "POS"] + matched[forward_strand, "spliceaiDP_AG" ] - 1
    matched[forward_strand, "spliceaiEL"] = matched[forward_strand, "POS"] + matched[forward_strand, "spliceaiDP_AL" ] - 1
    matched[forward_strand, "spliceaiSG"] = matched[forward_strand, "POS"] + matched[forward_strand, "spliceaiDP_DG" ]
    matched[forward_strand, "spliceaiSL"] = matched[forward_strand, "POS"] + matched[forward_strand, "spliceaiDP_DL" ]
  
    matched[forward_strand, c("spliceaiDS_EG", "spliceaiDS_EL", "spliceaiDS_SG", "spliceaiDS_SL")] = matched[forward_strand, c("spliceaiDS_AG", "spliceaiDS_AL", "spliceaiDS_DG", "spliceaiDS_DL")] >= 0
  }
  
  ### Redefine splice start site and end site at reverse strand
  reverse_strand = matched$strand == "-"
  if (sum(reverse_strand) > 0){
    matched[reverse_strand, "spliceaiSG"] = matched[reverse_strand, "POS"] + matched[reverse_strand, "spliceaiDP_AG" ]
    matched[reverse_strand, "spliceaiSL"] = matched[reverse_strand, "POS"] + matched[reverse_strand, "spliceaiDP_AL" ]
    matched[reverse_strand, "spliceaiEG"] = matched[reverse_strand, "POS"] + matched[reverse_strand, "spliceaiDP_DG" ] - 1
    matched[reverse_strand, "spliceaiEL"] = matched[reverse_strand, "POS"] + matched[reverse_strand, "spliceaiDP_DL" ] - 1
  
    matched[reverse_strand, c("spliceaiDS_SG", "spliceaiDS_SL", "spliceaiDS_EG", "spliceaiDS_EL")] = matched[reverse_strand, c("spliceaiDS_AG", "spliceaiDS_AL", "spliceaiDS_DG", "spliceaiDS_DL")] >= 0
  }
  matched$spliceaiSG_idx = paste(matched$chr, matched$spliceaiSG, matched$strand, matched$Gene_id, sep=":")
  matched$spliceaiEG_idx = paste(matched$chr, matched$spliceaiEG, matched$strand, matched$Gene_id, sep=":")
  matched$spliceaiSL_idx = paste(matched$chr, matched$spliceaiSL, matched$strand, matched$Gene_id, sep=":")
  matched$spliceaiEL_idx = paste(matched$chr, matched$spliceaiEL, matched$strand, matched$Gene_id, sep=":")
      
  match_sites = paste0("match_", c("SG", "SL", "EG", "EL"))
  score_sites = paste0("spliceai", c("DS_SG", "DS_SL", "DS_EG", "DS_EL"))
  
  matched[, match_sites] = FALSE
  
  ### Prediction on gain of annotated splice site & loss of novel splice site are out of scope
  matched[(matched$spliceaiDS_SG & (matched$spliceaiSG_idx %in% intron_ref$anno_start)), "spliceaiDS_SG"] = FALSE
  matched[(matched$spliceaiDS_EG & (matched$spliceaiEG_idx %in% intron_ref$anno_end)), "spliceaiDS_EG"] = FALSE
  matched[(matched$spliceaiDS_SL & (!matched$spliceaiSL_idx %in% intron_ref$anno_start)), "spliceaiDS_SL"] = FALSE
  matched[(matched$spliceaiDS_EL & (!matched$spliceaiEL_idx %in% intron_ref$anno_end)), "spliceaiDS_EL"] = FALSE
  
  ### Match lost of annotated sites 
  matched_cryptic_loss_all = subset(matched, (spliceaiDS_SL & (spliceaiSL_idx %in% intron_ref$anno_start)) | (spliceaiDS_EL & (spliceaiEL_idx %in% intron_ref$anno_end)) )
  for (var in unique(matched_cryptic_loss_all$VAR_id)){
    matched_cryptic_loss_var = subset(matched_cryptic_loss_all, VAR_id == var)
    if (sum(matched_cryptic_loss_var$spliceaiDS_SL)>0){
      annotated_end = unique(subset(intron_ref, anno_start %in% matched_cryptic_loss_var$spliceaiSL_idx, select = anno_end, drop=T))
      matched_cryptic_loss_var_ = subset(matched_cryptic_loss_var, end.pos %in% annotated_end)
      if (nrow(matched_cryptic_loss_var_) > 0){
        matched[matched$idx %in% matched_cryptic_loss_var_$idx, "match_SL"] = TRUE
      }
    }
    if (sum(matched_cryptic_loss_var$spliceaiDS_EL)>0){
      annotated_start = unique(subset(intron_ref, anno_end %in% matched_cryptic_loss_var$spliceaiEL_idx, select = anno_start, drop=T))
      matched_cryptic_loss_var_ = subset(matched_cryptic_loss_var, start.pos %in% annotated_start)
      if (nrow(matched_cryptic_loss_var_) > 0){
        matched[matched$idx %in% matched_cryptic_loss_var_$idx, "match_EL"] = TRUE
      }
    }
  }
  
  ### Match gained of novel site 
  matched_cryptic_gain = subset(matched, ((!spliceaiSG_idx %in% intron_ref$anno_start) & spliceaiDS_SG & spliceaiSG == start) | ((!spliceaiEG_idx %in% intron_ref$anno_end) & spliceaiDS_EG & spliceaiEG == end) )
  matched[matched$idx %in% matched_cryptic_gain[(matched_cryptic_gain$spliceaiSG == matched_cryptic_gain$start) & (!matched_cryptic_gain$spliceaiSG_idx %in% intron_ref$anno_start), "idx"], "match_SG"] = TRUE
  matched[matched$idx %in% matched_cryptic_gain[(matched_cryptic_gain$spliceaiEG == matched_cryptic_gain$end) & (!matched_cryptic_gain$spliceaiEG_idx %in% intron_ref$anno_end), "idx"], "match_EG"] = TRUE

  ### Use provided spliceai score threshold
  if (sum(matched$strand == "+") > 0){
    matched[matched$strand == "+", c("spliceaiDS_EG", "spliceaiDS_EL", "spliceaiDS_SG", "spliceaiDS_SL")] = matched[matched$strand == "+", c("spliceaiDS_AG", "spliceaiDS_AL", "spliceaiDS_DG", "spliceaiDS_DL")] >= min_SpliceAI_score
  }
  if (sum(matched$strand == "-") > 0){
    matched[matched$strand == "-", c("spliceaiDS_SG", "spliceaiDS_SL", "spliceaiDS_EG", "spliceaiDS_EL")] = matched[matched$strand == "-", c("spliceaiDS_AG", "spliceaiDS_AL", "spliceaiDS_DG", "spliceaiDS_DL")] >= min_SpliceAI_score
  } 
  
  ### Prediction on gain of annotated splice site & loss of novel splice site are out of scope
  matched[(matched$spliceaiDS_SG & (matched$spliceaiSG_idx %in% intron_ref$anno_start)), "spliceaiDS_SG"] = FALSE
  matched[(matched$spliceaiDS_EG & (matched$spliceaiEG_idx %in% intron_ref$anno_end)), "spliceaiDS_EG"] = FALSE
  matched[(matched$spliceaiDS_SL & (!matched$spliceaiSL_idx %in% intron_ref$anno_start)), "spliceaiDS_SL"] = FALSE
  matched[(matched$spliceaiDS_EL & (!matched$spliceaiEL_idx %in% intron_ref$anno_end)), "spliceaiDS_EL"] = FALSE

  ### Judge match or not by number of matched and mis-matched sites
  matched[, score_sites][ which(matched[, score_sites] == FALSE, arr.ind = T) ] = NA
  matched$matched_site = rowSums(matched[, score_sites] * matched[, match_sites], na.rm = T)
  matched$miss_matched_site = rowSums((matched[, score_sites] * matched[, match_sites]) == 0, na.rm = T)
  matched$match_by_threshold[matched$matched_site > 0 & matched$miss_matched_site == 0 ] = "full_match"
  matched$match_by_threshold[matched$matched_site > 0 & matched$miss_matched_site > 0] = "partial_match"
  matched$match_by_threshold[matched$matched_site == 0 & matched$miss_matched_site > 0] = "not_match"
  matched$match_by_threshold[matched$matched_site == 0 & matched$miss_matched_site == 0] = "not_match"
  
  ### 2 loss sites & 2 gain sites
  loss_2_idx = matched$spliceaiDS_SL & matched$spliceaiDS_EL & !is.na(matched$spliceaiDS_SL) & !is.na(matched$spliceaiDS_EL) & is.na(matched$spliceaiDS_SG) & is.na(matched$spliceaiDS_EG)
  matched[loss_2_idx & matched$start < matched$spliceaiSL & matched$end > matched$spliceaiEL & matched$matched_site == 1, "match_by_threshold" ] = "full_match"
  gain_2_idx = matched$spliceaiDS_SG & matched$spliceaiDS_EG & !is.na(matched$spliceaiDS_SG) & !is.na(matched$spliceaiDS_EG) & is.na(matched$spliceaiDS_SL) & is.na(matched$spliceaiDS_EL)
  matched[gain_2_idx & matched$matched_site == 1, "match_by_threshold" ] = "full_match"
  
  matched = matched[order(matched$VAR_id, -matched$matched_site), ]
  
  ### Add cryptic exon label if prediction match to discovered cryptic exons
  pred_cryptic_exon = !is.na(matched$spliceaiDS_SG & matched$spliceaiDS_EG) & (matched$spliceaiDS_SG & matched$spliceaiDS_EG) == TRUE
  matched[pred_cryptic_exon, "pred_cryptic_exon"] = paste(matched$chr, matched$spliceaiEG, matched$spliceaiSG, matched$strand, matched$Gene_id, sep=":")[pred_cryptic_exon]
  
  ### Count how many exons the cryptic introns skip
  matched_gr = GenomicRanges::makeGRangesFromDataFrame(matched, seqnames.field = "chr", start.field = "start", end.field = "end", strand.field = "strand", keep.extra.columns = TRUE)
  ref_exon = read.table(ref_exon, sep="\t", header = F, stringsAsFactors = F)
  colnames(ref_exon) = c("chr", "start", "end", "exon.id", "gene.id", "strand")
  ref_exon = ref_exon[!duplicated(ref_exon[, c("chr", "start", "end", "strand", "gene.id")]), ]
  ref_exon = ref_exon %>% dplyr::group_by(chr, gene.id, strand, start) %>% dplyr::summarise(across(end, max))
  ref_exon = data.frame(ref_exon %>% dplyr::group_by(chr, gene.id, strand, end) %>% dplyr::summarise(across(start, min)))
  ref_exon = GenomicRanges::makeGRangesFromDataFrame(ref_exon, seqnames.field = "chr", start.field = "start", end.field = "end", strand.field = "strand", keep.extra.columns = TRUE)
  overlap_exon = data.frame(GenomicRanges::findOverlaps(ref_exon, matched_gr, type = "within"))

  ref_exon = data.frame(ref_exon, stringsAsFactors=F)
  colnames(ref_exon) = paste0("exon_", colnames(ref_exon))
  idx = as.numeric(overlap_exon$subjectHits)
  overlap_exon = cbind(ref_exon[as.numeric(overlap_exon$queryHits), ], matched[as.numeric(overlap_exon$subjectHits), ])
  overlap_exon$idx = idx; rm(idx)
  overlap_exon = overlap_exon[overlap_exon$exon_gene.id == overlap_exon$gene.id, ]
  nr_exon_start = overlap_exon %>% dplyr::distinct(idx, exon_start) %>% dplyr::count(idx)
  nr_exon_end = overlap_exon %>% dplyr::distinct(idx, exon_end) %>% dplyr::count(idx)
  overlap_exon = dplyr::full_join(nr_exon_start, nr_exon_end, by="idx")
  overlap_exon$n = do.call(pmin, overlap_exon[, c("n.x", "n.y")])
  matched$junc_skip_nr_exon = 0
  matched[as.numeric(overlap_exon$idx), "junc_skip_nr_exon"] = overlap_exon$n
  
  matched[matched$junc_skip_nr_exon > max_skip_exon, "match_by_threshold"] = "not_match"
  matched
}
